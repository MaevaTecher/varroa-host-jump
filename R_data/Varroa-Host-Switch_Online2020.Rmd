---
title: "Online Ressource: Varroa Host Switch Genomics and Demography"
author: "Maeva A. Techer, Ecology and Evolution, OIST"
date: "(updated 2020-06-08)"
output: 
  html_document:
    toc: true 
    toc_float: true # make 
    depth: 3  
    number_sections: false 
    theme: flatly
    code_folding: hide #
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This online ressource is there to provide additional interactive visualization tool for the Varroa mites sampling and sequencing data obtained from the associated paper "XXXX". A Snakemake pipeline created and used for genomics mapping, variant calling and analysis is provided in this host GitHub repository. Most genomics and demographic analysis using fastsimcoal2 were computed on the Okinawa Institute of Science and Technology OIST cluster, Sango. 

Click on "code" button on the right to make appear the libraries used and R code for each section.

``` {r rawmetadata, message = FALSE, warning = FALSE, results="hide"}
library("tidyverse")
library("knitr") # for the markdown
library("kableExtra") # for creating a scrolling table
library("ggplot2") # for plotting 
library("maps")
library("leaflet")
library("htmltools")
library("rgdal")
library("gridExtra")
library("gghighlight")
library("adegenet")
library("vcfR")
library("ggmap")
library("poppr")
library("RColorBrewer")
library("gridExtra")
library("igraph")
library("StAMPP")
library("lattice")
library("reshape2")
library("ggrepel") # for text labels
library("pcadapt")
library("data.table")
library("ggthemes")
library("ggpubr")
library("boot")
library("plotly")
library("forcats")
library("plotly")

```

# 1. Distribution maps of the Varroa mites sampled

Here, we have 43 samples of Varroa mites for which we have sequenced the whole genome succesfully. We use the `leaflet` package to create an interactive map showing the location and from which host, each Varroa mite was collected.

*ID* = Name code of the samples obtained from the CSIRO varroa collection  
*Species* = Identified species according to mtDNA of the mtDNA COX1 partial gene  
*Host collected* = Varroa mites were collected from within honey bee colonies identified by the collector as either Western honey bee _Apis mellifera_ or Eastern honey bee _Apis cerana_.  
*Location/Country/Date* = Exact informations on sampling  
*Site* = Code name of each sampling site corresponding on the map
*Approximate.X/Y* = GPS coordinates from samples obtained before 2008 are infered from approximate location given. All samples geo-coordinates after 2008 were obtained directly from field collection.  
  
*COI_haplogroup* = mtDNA haplogroup identified from mtDNA COX1 partial region (reconstruct from HiSeq4000 reads and confirmed by Sanger sequencing).  
*Haplotype* = mtDNA haplotype name by concatenating four genes (COX1, COX3, ATP6 and ND2)  

*Host_read* = Host DNA identified by number of reads mapped against either _A. cerana_ or _A. mellifera_  
*reads_mellifera/cerana* = Number of reads mapped against reference genome of _A. cerana_ or _A. mellifera_ (Q > 20)

``` {r Map_base, message = FALSE, warning = FALSE}

# Import the metadata for the Varroa samples 
metadata <- read.csv("metadata_varroa_asia_15052020.csv", header = TRUE)
#head(metadata)

## Create a scrolling table
kable(cbind(metadata)) %>%
  kable_styling(bootstrap_options = "striped", font_size = 9)  %>%
  scroll_box(width = "100%", height = "400px") #%>%
  #row_spec(1:23, bold = T, color = "white", background = "#E60000") %>%
  #row_spec(24:39, bold = T, color = "white", background = "#FF9999")  %>%
  #row_spec(40:74, bold = T, color = "white", background = "#0000FF")  %>%
  #row_spec(75:96, bold = T, color = "white", background = "#3399FF")

# Download the country borders layer
#download.file("http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip" , destfile="world_shape_file.zip")
#system("unzip world_shape_file.zip")
world_spdf=readOGR(dsn= getwd() , layer="TM_WORLD_BORDERS_SIMPL-0.3")

data.vdac <- metadata %>% filter(Species == "V. destructor") %>% filter(Host_collected == "A. cerana") 

data.vdam <- metadata %>% filter(Species == "V. destructor") %>% filter(Host_collected == "A. mellifera")

data.vjac <- metadata %>% filter(Species == "V. jacobsoni") %>% filter(Host_collected == "A. cerana") 

data.vjam <- metadata %>% filter(Species == "V. jacobsoni") %>% filter(Host_collected == "A. mellifera") 
``` 

The following interactive map showed the distribution of both _V. destructor_ and _V. jacobsoni_ samples on either their original host the eastern honey bee _A. cerana_ or on the new host the western honey bee _A. mellifera_.
  
If you pass your mouse over a particular point, a pop-up will appear presenting essential information about the particular Varroa mite sample. On the right top corner, a layer control button allow to subselect species/host couple.

<span style="color:red">*V. destructor* on *A. cerana*</span>  
<span style="color:pink">*V. destructor* on *A. mellifera*</span>  
<span style="color:blue">*V. jacobsoni* on *A. cerana*</span>    
<span style="color:cyan">*V. jacobsoni* on *A. mellifera*</span>


``` {r Map_mites, message = FALSE, warning = FALSE}

## Create the interactive map with leaflet
leaflet(metadata) %>% 
  addTiles(group = "OSM (default)") %>%
  ## add the layer other than default we would like to use for background
  addProviderTiles(providers$CartoDB.PositronNoLabels, group = "Positron NoLabels") %>%
  ## adding the layers with V. destructor
  addCircleMarkers(data = data.vdac, data.vdac$Approximate.Y, data.vdac$Approximate.X,
                   weight = 0.5,
                   col = "#FB0000", 
                   radius = 4, 
                   fillOpacity = 0.9, 
                   stroke = T, 
                   popup = ~paste(sep = "<br/>",
                              paste ("Name: ", as.character(ID)),
                              paste ("Host: ", as.character(Host_collected)),
                              paste ("Date: ", as.character(Date)),
                              paste ("mtDNA: ", as.character(Haplotype))),
                   group = 'V. destructor on A. cerana') %>%

  addCircleMarkers(data = data.vdam, data.vdam$Approximate.Y, data.vdam$Approximate.X,
                   weight = 0.5,
                   col = "#FF9999", 
                   radius = 4, 
                   fillOpacity = 0.9, 
                   stroke = T, 
                   popup = ~paste(sep = "<br/>",
                              paste ("Name: ", as.character(ID)),
                              paste ("Host: ", as.character(Host_collected)),
                              paste ("Date: ", as.character(Date)),
                              paste ("mtDNA: ", as.character(Haplotype))),
                   group = 'V. destructor on A. mellifera') %>%

  ## adding the layers with V. jacobsoni
  addCircleMarkers(data = data.vjac, data.vjac$Approximate.Y, data.vjac$Approximate.X,
                   weight = 0.5,
                   col = "#0000FF", 
                   radius = 4, 
                   fillOpacity = 0.9, 
                   stroke = T, 
                   popup = ~paste(sep = "<br/>",
                              paste ("Name: ", as.character(ID)),
                              paste ("Host: ", as.character(Host_collected)),
                              paste ("Date: ", as.character(Date)),
                              paste ("mtDNA: ", as.character(Haplotype))),
                   group = 'V. jacobsoni on A. cerana') %>%

  addCircleMarkers(data = data.vjam, data.vjam$Approximate.Y, data.vjam$Approximate.X,
                   weight = 0.5,
                   col = "#00CCFF", 
                   radius = 4, 
                   fillOpacity = 0.9, 
                   stroke = T,    
                   popup = ~paste(sep = "<br/>",
                              paste ("Name: ", as.character(ID)),
                              paste ("Host: ", as.character(Host_collected)),
                              paste ("Date: ", as.character(Date)),
                              paste ("mtDNA: ", as.character(Haplotype))),
                   group = 'V. jacobsoni on A. mellifera') %>%

    ## adding the control button to remove or add layers of points 
  addLayersControl(position = "topright",
    baseGroups = c("OSM (default)", "Positron NoLabels"),
    overlayGroups = c("V. destructor on A. cerana", 
                      "V. destructor on A. mellifera", 
                      "V. jacobsoni on A. cerana", 
                      "V. jacobsoni on A. mellifera"), 
    options = layersControlOptions(collapsed = TRUE))  %>%
  ## show the positron background prerably to the OSM layer
  showGroup("Positron NoLabels")

```

# 2. Reads and mapping statistics for Varroa libraries

Here we plot the mean read depth computed from each .bam file mapped to the reference vdes3.0.fasta using `samtools depth -a FILE.bam | awk '{c++;s+=$3}END{print s/c}'` in relation to the mapping percentage.

As you can see by moving your pointer on the graph, the individual `V788_1` has been removed from the analysis and replaced by the replicate `V788_2` with much better reads statistics.

```{r readsstats1, message = FALSE, warning = FALSE}

raichu <- ggplot(metadata, aes(x=Mapping_rate, y = Mean_Read_Depth, col=Species, shape=Host_collected, label = ID))
mycol = c("red2", "blue2")
raichu <- raichu + geom_point(size = 3)
raichu <- raichu + scale_color_manual(values = mycol)
raichu <- raichu + scale_size_manual(values = mycol)
raichu <- raichu +  theme_calc()
raichu <- raichu +  xlab("Mapping rate to Vdes_3.0 reference genome(%)")
raichu <- raichu +  ylab("Mean average read depth")
raichu <- raichu +  ylim(0,20)
#raichu

## make an interactive version of the scatter plot
intraichu <- ggplotly(raichu)
intraichu
```

We highlight the mean read depth regarding the general distribution, where is each group of individuals "species per host" located in it.

```{r readsstats2, message = FALSE, warning = FALSE}

evoli <- ggplot(metadata, aes(Mean_Read_Depth, fill = Species))
evoli <- evoli + geom_histogram(bins = 44) 
evoli <- evoli + gghighlight() 
evoli <- evoli + facet_wrap(~Species~Host_collected)
evoli <- evoli + scale_fill_manual(values = c("red", "blue"))
evoli <- evoli + theme_classic()
evoli <- evoli + labs(x = "Mean Read Depth using NextGenMap", y = "Number of samples")
evoli <- evoli + ggtitle("Read depth does not appear as unbalanced accross species and host")
evoli
```

Following is a plot of the total number of reads generated per individual and the proportion of reads mapped onto the reference.

```{r readsstats3, message = FALSE, warning = FALSE, results="hide"}

togepi <- ggplot(metadata, aes(x=ID, label = Mapping_rate))
togepi <- togepi + geom_bar(aes(weight=Total_reads), fill="black", position="dodge")
togepi <- togepi + geom_bar(aes(weight=Mapped), fill="#1d96f2", position="dodge")
togepi <- togepi + theme(axis.text.x = element_text(angle = 90, hjust = 1))
togepi <- togepi + labs(x = "Individuals", y = "Number of reads")
togepi <- togepi + ggtitle("Proportion of reads mapped against reference using NextGenMap")
togepi
```

# 3. Variation in the body size

Before proceeding to DNA extraction with a destructive method, we measured the body size of each Varroa mite whenever possible on both dorsal and ventral view. We measured seven morphological characters but retained only the body width and length for comparison here between Varroa species and their associated honey bee hosts.

The scatterplot also shows the average values obtained by Anderson and Trueman (2000) _Exp. App. Acar._ for _V. destructor_, _V. jacobsoni_ and undetermined mites from Luzon and Mindanao. 

``` {r Morpho_plot, message = FALSE, warning = FALSE}
# Table with 512 morpho data for the moment
morpho <- read.csv("Varroa-morpho-subset.csv", header = TRUE)
#kable(cbind(morpho)) %>%
#  kable_styling(bootstrap_options = "striped", font_size = 10) %>%
#  scroll_box(width = "100%", height = "400px")

morpho %>% 
  plot_ly(x = ~BW_V, y = ~BL_V,
          color = ~Species,
          symbol = ~Host,
          hoverinfo = "text",
          text = ~paste("Name: ", Sample.ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host, "<br>",
                        "Country: ", Country.Island)) %>%
  add_markers(colors = c("indianred2", "red3", "skyblue2", "blue2", "black"), 
              symbols = c( "triangle-up", "circle", "x"), 
              size = 3) %>%
  layout(xaxis = list(title = "Body width (mm)"),
         yaxis = list(title = "Body length (mm)"),
         title = "Variation in body size measured from ventral view")

  
morpho %>% 
  plot_ly(x = ~BW_D, y = ~BL_D,
          color = ~Species,
          symbol = ~Host,
          hoverinfo = "text",
          text = ~paste("Name: ", Sample.ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host, "<br>",
                        "Country: ", Country.Island)) %>%
  add_markers(colors = c("indianred2", "red3", "skyblue2", "blue2", "black"), 
              symbols = c( "triangle-up", "circle", "x"), 
              size = 3) %>%
  layout(xaxis = list(title = "Body width (mm)"),
         yaxis = list(title = "Body length (mm)"),
         title = "Variation in body size measured from dorsal view")

```

STATS TEST?

# 4. Genetic diversity on 43 samples and two species confonded
## 2D and 3D PCAs on ~ 1.4 million filtered biallelic SNPs

After formatting the variant call file `.vcf` into a `plink` format by renaming each chromosome (e.g., NW_019211454.1 by 1, NW_019211455.1 by 2, ...), and applying the option `pca`, we obtained the two files `.eigenval` and `.eigenvec`.

The following 2D and 3D PCAs are based on the ~1.4 million biallelic SNPs with a minor allelic frequency higher than 5%.

``` {r PCA-all, message = FALSE, warning = FALSE}

pca.all<- read_table2("43indplink.eigenvec", col_names = FALSE)
eigenval.all <- scan("43indplink.eigenval")

## Here the first two columns contains the individuals names as we did not specify it in plink earlier
# We remove the first column and assign the new name of column 1
pca.all <- pca.all[,-1]
names(pca.all)[1] <- "ID_NAMES"

# Rename the columns for PCA axis 
names(pca.all)[2:ncol(pca.all)] <- paste0("PC", 1:(ncol(pca.all)-1))

## Joint both table by using the FILE_ID as common parameters
metapca.all <- left_join(pca.all, metadata, by = c("ID_NAMES" = "SEQ_ID"))

### PLOTS
# first convert to percentage variance explained
pve <- data.frame(PC = 1:20, pve = eigenval.all/sum(eigenval.all)*100)

# make Eigenplot
a <- ggplot(pve, aes(PC, pve)) + geom_bar(stat = "identity")
a + ylab("Percentage variance explained") + theme_light()

metapca.all %>% 
  plot_ly(x = ~PC1, y = ~PC2,
          color = ~Species,
          symbol = ~Host_collected,
          hoverinfo = "text",
          text = ~paste("Name: ", ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host_collected, "<br>",
                        "Country: ", Country)) %>%
  add_markers(colors = c("red3", "blue2"), 
              symbols = c( "triangle-up", "circle"), 
              size = 4)%>%
  layout(title = "Varroa mites genetically differentiate between hosts in both species")

metapca.all %>% 
  plot_ly(x = ~PC1, y = ~PC2, z = ~PC3,
          color = ~Country,
          hoverinfo = "text",
          text = ~paste("Name: ", ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host_collected, "<br>",
                        "Country: ", Country,
                        "Haplogroup: ", COI_haplogroup)) %>%
  add_markers(colors = c("red3", "purple", "blue2", "green", "orange", "brown", "pink"), 
              size = 10) %>%
  layout(title = "Mites on A. cerana genetically differs within the native range")

metapca.all %>% 
  plot_ly(x = ~PC1, y = ~PC2, z = ~PC3,
          color = ~COI_haplogroup,
          hoverinfo = "text",
          text = ~paste("Name: ", ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host_collected, "<br>",
                        "Country: ", Country,
                        "Haplogroup: ", COI_haplogroup)) %>%
  add_markers(colors = c("red3", "purple", "blue2", "green", "orange", "brown", "pink"), 
              size = 10) %>%
  layout(title = "Mitochondrial lineages can be a pre-indicator of whole genome differentiation")

```

## 2D and 3D PCAs on ~ 200,000 biallelic SNPs pruned for LD

Same idea as the previous PCA, except that only 236,713 SNPs were kept to reduce the effect of linkage disequilibrium.

We can see that even with a smaller reduce number of SNPs, Varroa mites species are genetically distinct and 

``` {r PCA-allLDpruned, message = FALSE, warning = FALSE}

pca.allLD<- read_table2("43ind-ldpruned.eigenvec", col_names = FALSE)
eigenval.allLD <- scan("43ind-ldpruned.eigenval")

## Here the first two columns contains the individuals names as we did not specify it in plink earlier
# We remove the first column and assign the new name of column 1
pca.allLD <- pca.allLD[,-1]
names(pca.allLD)[1] <- "ID_NAMES"

# Rename the columns for PCA axis 
names(pca.allLD)[2:ncol(pca.allLD)] <- paste0("PC", 1:(ncol(pca.allLD)-1))

## Joint both table by using the FILE_ID as common parameters
metapca.allLD <- left_join(pca.allLD, metadata, by = c("ID_NAMES" = "SEQ_ID"))

### PLOTS
# first convert to percentage variance explained
pve <- data.frame(PC = 1:20, pve = eigenval.allLD/sum(eigenval.allLD)*100)

# make Eigenplot
a <- ggplot(pve, aes(PC, pve)) + geom_bar(stat = "identity")
a + ylab("Percentage variance explained") + theme_light()

metapca.allLD %>% 
  plot_ly(x = ~PC1, y = ~PC2,
          color = ~Species,
          symbol = ~Host_collected,
          hoverinfo = "text",
          text = ~paste("Name: ", ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host_collected, "<br>",
                        "Country: ", Country)) %>%
  add_markers(colors = c("red3", "blue2"), 
              symbols = c( "triangle-up", "circle"), 
              size = 4) %>%
  layout(title = "~200,000 LD pruned SNPs still allowed to see host genetic divergence")


metapca.allLD %>% 
  plot_ly(x = ~PC1, y = ~PC2, z = ~PC3,
          color = ~Country,
          hoverinfo = "text",
          text = ~paste("Name: ", ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host_collected, "<br>",
                        "Country: ", Country,
                        "Haplogroup: ", COI_haplogroup)) %>%
  add_markers(colors = c("red3", "purple", "blue2", "green", "orange", "brown", "pink"), 
              size = 10) %>%
  layout(title = "3D PCA color-coded by country")

metapca.allLD %>% 
  plot_ly(x = ~PC1, y = ~PC2, z = ~PC3,
          color = ~COI_haplogroup,
          hoverinfo = "text",
          text = ~paste("Name: ", ID, "<br>",
                        "Species: ", Species, "<br>",
                        "Host: ", Host_collected, "<br>",
                        "Country: ", Country,
                        "Haplogroup: ", COI_haplogroup)) %>%
  add_markers(colors = c("red3", "purple", "blue2", "green", "orange", "brown", "pink"), 
              size = 10) %>%
  layout(title = "3D PCA color-coded by mtDNA COX1 haplogroup")


```

# 5. Demography and best scenario bootstraps

After estimating the demographic history for each Varroa species on their novel and original hosts using `fastsimcoal2`, we plotted here the distribution of the log likelihood from the 100 run replicates for each scenario and each SFS subset size.

This method for model selection comes on top of the AIC calculation and is followed the same methods as described in [Meier et al. 2016. Mol. Ecol.](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.13838). For the AIC values, see Table S7.

## _Varroa destructor_ demographic history
### Likelihood distribution for the four VD SFS datasets
```{r lhoodsvd, message = FALSE, warning = FALSE, cache = "TRUE"}

vd.lhoods1050 <- read.csv("fsc_run/lhoods_1050SNPS_vdno475.csv", header = TRUE)
vd.lhoods10500 <- read.csv("fsc_run/lhoods_10500SNPS_vdno475.csv", header = TRUE)
vd.lhoods35000 <- read.csv("fsc_run/lhoods_35000SNPS_vdno475.csv", header = TRUE)
vd.lhoods105000 <- read.csv("fsc_run/lhoods_105000SNPS_vdno475.csv", header = TRUE)

par(mfrow=c(1,4))
#Plot 1 for likelihoods with smaller subset
boxplot(range = 0,vd.lhoods1050$scenario1_div [3:102], vd.lhoods1050$scenario2_divGwt2n[3:102], vd.lhoods1050$scenario3_divGwt[3:102], vd.lhoods1050$scenario4_IM[3:102], vd.lhoods1050$scenario5_IMGwt2n[3:102], vd.lhoods1050$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vd.lhoods1050$scenario1_div [2],col = "red", pch = 20)
points(2,vd.lhoods1050$scenario2_divGwt2n [2],col = "red", pch = 20)
points(3,vd.lhoods1050$scenario3_divGwt [2],col = "red", pch = 20)
points(4,vd.lhoods1050$scenario4_IM [2],col = "red", pch = 20)
points(5,vd.lhoods1050$scenario5_IMGwt2n [2],col = "red", pch = 20)
points(6,vd.lhoods1050$scenario6_IMGwt [2],col = "red", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. destructor 377 SNPS")

#Plot 2 for likelihoods with second smaller subset
boxplot(range = 0,vd.lhoods10500$scenario1_div [3:102], vd.lhoods10500$scenario2_divGwt2n[3:102], vd.lhoods10500$scenario3_divGwt[3:102], vd.lhoods10500$scenario4_IM[3:102], vd.lhoods10500$scenario5_IMGwt2n[3:102], vd.lhoods10500$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vd.lhoods10500$scenario1_div [2],col = "red", pch = 20)
points(2,vd.lhoods10500$scenario2_divGwt2n [2],col = "red", pch = 20)
points(3,vd.lhoods10500$scenario3_divGwt [2],col = "red", pch = 20)
points(4,vd.lhoods10500$scenario4_IM [2],col = "red", pch = 20)
points(5,vd.lhoods10500$scenario5_IMGwt2n [2],col = "red", pch = 20)
points(6,vd.lhoods10500$scenario6_IMGwt [2],col = "red", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. destructor 3,760 SNPS")

#Plot 3 for likelihoods with third subset
boxplot(range = 0,vd.lhoods35000$scenario1_div [3:102], vd.lhoods35000$scenario2_divGwt2n[3:102], vd.lhoods35000$scenario3_divGwt[3:102], vd.lhoods35000$scenario4_IM[3:102], vd.lhoods35000$scenario5_IMGwt2n[3:102], vd.lhoods35000$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vd.lhoods35000$scenario1_div [2],col = "red", pch = 20)
points(2,vd.lhoods35000$scenario2_divGwt2n [2],col = "red", pch = 20)
points(3,vd.lhoods35000$scenario3_divGwt [2],col = "red", pch = 20)
points(4,vd.lhoods35000$scenario4_IM [2],col = "red", pch = 20)
points(5,vd.lhoods35000$scenario5_IMGwt2n [2],col = "red", pch = 20)
points(6,vd.lhoods35000$scenario6_IMGwt [2],col = "red", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. destructor 12,665 SNPS")

#Plot 4 for likelihoods with larger subset
boxplot(range = 0,vd.lhoods105000$scenario1_div [3:102], vd.lhoods105000$scenario2_divGwt2n[3:102], vd.lhoods105000$scenario3_divGwt[3:102], vd.lhoods105000$scenario4_IM[3:102], vd.lhoods105000$scenario5_IMGwt2n[3:102], vd.lhoods105000$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vd.lhoods105000$scenario1_div [2],col = "red", pch = 20)
points(2,vd.lhoods105000$scenario2_divGwt2n [2],col = "red", pch = 20)
points(3,vd.lhoods105000$scenario3_divGwt [2],col = "red", pch = 20)
points(4,vd.lhoods105000$scenario4_IM [2],col = "red", pch = 20)
points(5,vd.lhoods105000$scenario5_IMGwt2n [2],col = "red", pch = 20)
points(6,vd.lhoods105000$scenario6_IMGwt [2],col = "red", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. destructor 38,108 SNPS")
```

After summarizing the 100 best replicates from the 100 simulated SFS run, we computed the mean estimate value and 95% confidence interval for each demographic parameter using `boot` package.

### Scenario 6: IM + BOT bootstraps computation
```{r vdboot6, message = FALSE, warning = FALSE}

my.mean = function(x, indices) {
return( mean( x[indices] ) )
}

# import the file containing the 100 best runs
vd.boot6 <- read.csv("fsc_run/vdno475_105000nopv_BOOT.csv", header = TRUE)

# Effective size for Varroa mites on original host Apis cerana
N_VdAc1.boot = boot(vd.boot6$NVDAC1, my.mean, 10000)
my.mean(vd.boot6$NVDAC1,1:length(vd.boot6$NVDAC1))
boot.ci(N_VdAc1.boot)

# Effective size for Varroa mites on new host Apis mellifera
N_VdAm0.boot = boot(vd.boot6$NVDAM0, my.mean, 10000)
my.mean(vd.boot6$NVDAM0,1:length(vd.boot6$NVDAM0))
boot.ci(N_VdAm0.boot)

# Number of generations when new population of Varroa mites was founded
TBOT.boot = boot(vd.boot6$TBOT, my.mean, 10000)
my.mean(vd.boot6$TBOT,1:length(vd.boot6$TBOT))
boot.ci(TBOT.boot)

# Growth rate of Varroa mites on new host Apis mellifera
GAM.boot = boot(vd.boot6$GAM, my.mean, 10000)
my.mean(vd.boot6$GAM,1:length(vd.boot6$GAM))
boot.ci(GAM.boot)

# Effective size for Varroa mites able to jump on A. mellifera to create new population
JUMP.boot = boot(vd.boot6$JUMP, my.mean, 10000)
my.mean(vd.boot6$JUMP,1:length(vd.boot6$JUMP))
boot.ci(JUMP.boot)

N0M1.boot = boot(vd.boot6$N0M1, my.mean, 10000)
my.mean(vd.boot6$N0M1,1:length(vd.boot6$N0M1))
boot.ci(N0M1.boot)

N1M0.boot = boot(vd.boot6$N1M0, my.mean, 10000)
my.mean(vd.boot6$N1M0,1:length(vd.boot6$N1M0))
boot.ci(N1M0.boot)

MACtoAM.boot = boot(vd.boot6$MACtoAM, my.mean, 10000)
my.mean(vd.boot6$MACtoAM,1:length(vd.boot6$MACtoAM))
boot.ci(MACtoAM.boot)

MAMtoAC.boot = boot(vd.boot6$MAMtoAC, my.mean, 10000)
my.mean(vd.boot6$MAMtoAC,1:length(vd.boot6$MAMtoAC))
boot.ci(MAMtoAC.boot)
```

Here we modified the `.par` file from the best scenario 6 for _V. destructor_ by adding the mean values computed in the step before. Using the `ParFileInterpreter-v6.3.1.r` developed by Victor Sousa and available on fastsimcoal2 website, we can now visulized the best demographic scenario.

### Draw parameters for best scenario with mean bootstraps
```{r sousaexcoffierdrawvd, warning = FALSE}
#...........................................................................................
# (c) Laurent Excoffier and Vitor Sousa June-November 2015
# 
# Small R program to draw the evolutonary scenario described by a given par file
# This is mainly for visual checking that the modeled scenario corresponds to   
# what was intended
#
#...........................................................................................
#
args=commandArgs(TRUE)
print(args)

#Expects par file name on command line

if(length(args)) {
  parFileName=args[1]
} else {  
  #REPLACE BY THE NAME OF THE PAR FILE YOU WANT TO ANALYSE
  parFileName="fsc_run/VDM6_downsample_IMGwt_49_boot.par"
}

separator=" "
migrMatCol="coral"
admixCol="blue"
popFusionColor="black"
popCol="lightgrey"
popBorderCol="black"
inbreedColor="lightblue"
oldSampColor="olivedrab4"
timeCol="tan4"
growthCol="hotpink3"
propLastsegment=0.05
migMatNameProp=0.8
migMatLineLength=0.3
timeProp=0.6
maxRadius=1/40
minRadius=maxRadius/3
arrowLength=0.2
logScaleAxis=""
timeOffset=0.25
migrOffset=0.1
curvedArrowLTY=1
drawLogPopSize=T
plotMigrRates=T
migrRateTextSizeCEX=0.5

#Define plot area size for PDF
pdf.x.size=7
pdf.y.size=10

rescalingFactor=1.0 #Don't touch this!


printPDF=F

# parFile=readLines(con=parFileName)

###########################      Reading par file      #########################

parFile=scan(parFileName, character(0), sep = "\n", strip.white = TRUE) # separate each line

#pdfFileName=paste(parFileName, ".pdf", sep="")

#--- Clean input file by removing consecutive separators, and keep ---------------

#--- Function to remove separators within a string
removeTrailingSep=function(string, sep) {
  temp=strsplit(string, split=sep)
  temp2=temp[[1]][nchar(temp[[1]])>0]
  cleanStr=temp2[1]
  if (length(temp2)>1) {
    for (i in 2:length(temp2)) {
      cleanStr=paste(cleanStr, temp2[i], sep=sep)
    }
  }
  cleanStr
}

#--- Replace Keep by -9999
replaceKeep=function(string) {
  if (grepl("keep", string)) {
    return(gsub("keep", "-9999", string))
  }
  return(string)
}

#Remove both multiple consecutive whitespace and tabs and replace keep keyword
for (i in 1:length(parFile)) {
  parFile[i]=removeTrailingSep(parFile[i], sep='\t')
  parFile[i]=removeTrailingSep(parFile[i], sep=' ')
  parFile[i]=replaceKeep(parFile[i])
}

#-------------------------------------------------------------------------------

#--- Get number of samples on line 2 -----
l.numsamples=parFile[2]
sp.l=unlist(strsplit(l.numsamples, split=' '))
tab.l=unlist(strsplit(l.numsamples, split='\t'))
if (length(sp.l)>=length(tab.l)) {
  numSamples=as.numeric(sp.l[1])
  separator=" "
} else {
  numSamples=as.numeric(tab.l[1])
  separator="\t"
}

#--- Reading numbers on separate lines -----
getNumbers=function(start, parFile, numSamples) {  
  for (i in 1:numSamples) {
    curnum=as.numeric(unlist(strsplit(parFile[start+i], split=separator))[1])
    if (i==1) {
      num=curnum 
    } else {
      num=c(num, curnum)
    }
  }
  num
}

#--- Get population sizes -----------------
start=3
popSizes=getNumbers(start, parFile, numSamples)
#Rescaling pop sizes
popSizes=round(popSizes*rescalingFactor, digits=0)

iniPopSizes=popSizes

#--- Get sample sizes -----------------

readSampleSizesTimesAndInbreedingLevel=function(start, parFile, numSamples) {
  for (i in 1:numSamples) {
    curLine=unlist(strsplit(parFile[start+i], split=separator))
    curSampSize=as.numeric(curLine[1])
    curSampTime=0
    curInbreeding=0
    if (length(curLine)>1) curSampTime=as.numeric(curLine[2])
    if (length(curLine)>2) curInbreeding=as.numeric(curLine[3])
    if (i==1) {
      sampSize=curSampSize
      sampTime=curSampTime
      inbreeding=curInbreeding
    } else {
      sampSize=c(sampSize,curSampSize)
      sampTime=c(sampTime,curSampTime)
      inbreeding=c(inbreeding,curInbreeding)
    }
  }
  list(ss=sampSize, st=sampTime, inb=inbreeding)
}

start=start+numSamples+1
# sampSizes=getNumbers(start, parFile, numSamples)
sampSizesStats=readSampleSizesTimesAndInbreedingLevel(start, parFile, numSamples)
#Rescaling sample times
sampSizesStats$st=round(sampSizesStats$st*rescalingFactor, digits=0)

sampSizes=sampSizesStats$ss
sampTimes=sampSizesStats$st
inbrCoeff=sampSizesStats$inb

#--- Get growth rates -----------------
start=start+numSamples+1
growthRatesInitial=getNumbers(start, parFile, numSamples)
# save this into growthRates which will be used and updated when printing historical events
growthRates=growthRatesInitial

#--- Get number of migration matrices -----------------
start=start+numSamples+1
numMigMat=as.numeric(unlist(strsplit(parFile[start+1], split=separator))[1])

#--- Read migration matrix
readMigMat=function(start, parFile, numSamples) {
  for (i in 1:numSamples) {
    curmigs=as.numeric(unlist(strsplit(parFile[start+i], split=separator)))
    if (i==1) {
      migs=curmigs 
    } else {
      migs=rbind(migs, curmigs)
    }
  }
  rownames(migs)=1:numSamples
  migs 
}

#--- Get migration matrices as a list --------------
start=start+2
migMats=list()
if (numMigMat>0) {
  for (i in 1:numMigMat) {  
    curMigMat=readMigMat(start, parFile, numSamples) 
    migMats[[i]]=curMigMat
    start=start+numSamples+1
  }
}

#Rescaling migration rates
if (numMigMat>0) {
  for (i in 1:numMigMat) {
    migMats[[i]]=migMats[[i]]/rescalingFactor
  }
}

#--- Get number of historical events
start=start+1
numHistEvents=as.numeric(unlist(strsplit(parFile[start], split=separator))[1])

###################### HISTORICAL EVENTS HANDLING ##############################

#..... Read Historical Event .......
last.he.time=0
if (numHistEvents>0) {
  for (i in 1:numHistEvents) {
    start=start+1
    #Take care of nomig keyword
    nomig=F
    if (grepl("nomig", parFile[start])) {
      nomig=T
      gsub("nomig", "", parFile[start])
    }
    curHE=as.numeric(unlist(strsplit(parFile[start], split=separator)))
    if (nomig) curHE[7]=-1 
    #Rescaling time of event
    curHE[1]=round(curHE[1]*rescalingFactor, digits=0)
    if (i==1) {
      histEvents=curHE
      last.he.time=curHE[1]
    } else {
      histEvents=rbind(histEvents, curHE)
      if (histEvents[i,1] > last.he.time) last.he.time=histEvents[i,1] 
    }
  }
  if (numHistEvents>1) rownames(histEvents)=1:numHistEvents
}
names(last.he.time)=""
last.he.time=as.numeric(last.he.time)

yTimeLimit=0
if (last.he.time!=0) yTimeLimit=last.he.time*(1+propLastsegment) #Add propLastsegment to y axis after last event (to draw stuff)

#Reorder events by their times
if (numHistEvents>1) histEvents=histEvents[order(histEvents[,1],decreasing=FALSE),] else {
  if (numHistEvents==1) histEvents=matrix(histEvents, nrow=1,  byrow = T)
}

endReadParFile=start



##############################  PLOTTING THE MODELED SCENARIO ######################################


#--- Graphical functions ...........................................................................

fullHeadArrow=function(x0, y0, x1, y1, length, angle, color="black",  weight=1) {
  arrows(x0, y0, x1, y1, length, angle, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.80, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.60, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.40, code=2, lty=1, col=color, lwd=weight) 
  arrows(x0, y0, x1, y1, length, angle*0.20, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.10, code=2, lty=1, col=color, lwd=weight)
}
drawTriangle=function(growth, x, y, size, aspRatio, color) {
  if (growth>0) {
    x0=x; y0=y
    x1=x-size/2; y1=y+size/2*aspRatio
    x2=x+size/2; y2=y+size/2*aspRatio
  } else {
    x0=x-size/2; y0=y
    x1=x; y1=y+size/2*aspRatio
    x2=x+size/2; y2=y
  }
  polygon(c(x0, x1, x2, x0), c(y0, y1, y2, y0), col=color)
  return(y+size/2*aspRatio)
}


#--- Computing maximum current pop size ............................................................
maxPopSize=popSizes[1]
minPopSize=popSizes[1]
if (length(popSizes)>1){
  for (i in 2:length(popSizes)) {
    if (popSizes[i]>maxPopSize) maxPopSize=popSizes[i];
    if (popSizes[i]<minPopSize) minPopSize=popSizes[i];
  }
}

#--- Find min and max pop sizes over the whole population history ..................................
ps=popSizes
isGrowth=FALSE
if (numHistEvents) {
  #Need to keep track ofgrowth rates over time
  gRates=growthRates
  prevTime=0
  for (i in 1:numHistEvents) {
    he=histEvents[i,]
    curTime=he[1]
    sink=he[3]+1 
    resize=he[5]
    growth=he[6]
    
    #Begin by resizing pop sizes due to growth since last event
    for (j in 1:length(ps)) {
      ps[j]=ps[j]*exp(gRates[j]*(curTime-prevTime))
      if (ps[j]>maxPopSize) maxPopSize=ps[j]
      if (ps[j]<minPopSize) minPopSize=ps[j]
      if (ps[j]==0) print(paste("Deme ", j-1, " reaches size zero at time ",  curTime, " due to large negative growth (", gRates[j], ")", sep=""))
      if (is.infinite(ps[j])) print(paste("Deme ", j-1, " reaches infinite size at time ",  curTime, " due to large positive growth (", gRates[j], ")", sep=""))
    }
    prevTime=curTime
    
    #Handle transformed keep keyword
    if(growth!=-9999) {
      gRates[sink]=growth 
    }
    
    #Implement resize
    ps[sink]=ps[sink]*resize
    if (ps[sink]>maxPopSize) maxPopSize=ps[sink]
    if (ps[sink]<minPopSize) minPopSize=ps[sink]
  }
}

#-- Function to compute the circle radius for a given pop size ....................................
interpolRadius=function(curSize, minSize, maxSize, minRadius, maxRadius, logScale) {
  if(logScale) {
    minSize=log10(minSize)
    maxSize=log10(maxSize)
    curSize=log10(curSize)
  }
  curRadius=minRadius+(curSize-minSize)*(maxRadius-minRadius)/(maxSize-minSize)
  curRadius
}

#==============================                     ========================
#==============================   BEGIN MAIN PLOT   ========================
#==============================                     ========================

library("plotrix")
library("diagram")

if (printPDF) {
  pdf(pdfFileName, width=pdf.x.size, height=pdf.y.size)
} 

par(xpd=F, mar=c(6,4,3,0.5))

maxRadius=maxRadius*(numSamples+2)
minRadius=minRadius*(numSamples+2)

title=parFileName

plot(x=1:numSamples, type="n", xlab="", ylab="time (gen)", xlim=c(-0.5, numSamples+1.5), cex.main=0.8,
     ylim=c(0, yTimeLimit), main=title, xaxt = 'n', log=logScaleAxis, cex.axis=0.9, cex.lab=0.9)
axis(side=1, labels=c("Mig Mat",0:(numSamples-1), " \nTimes"), at=0:(numSamples+1), cex.axis=0.8)
mtext("demes", side=1,line=2, cex=0.8)

w <- par("pin")[1]/diff(par("usr")[1:2])
h <- par("pin")[2]/diff(par("usr")[3:4])
aspRatio <- w/h

# aspRatio=yTimeLimit/(numSamples+2)

#--- Plotting population circles according to their current size and sampling time
for (i in 1:numSamples) {
  curRadius=interpolRadius(popSizes[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
  #   print(curRadius)
  if (i==1) topOfCircle=sampTimes[i]+curRadius*aspRatio else topOfCircle=c(topOfCircle, sampTimes[i]+curRadius*aspRatio)
  curColor=popCol
  if (sampSizes[i]==0) curColor="white"
  if (inbrCoeff[i]==0) {
    draw.circle(i, sampTimes[i], radius = curRadius, col=curColor, border=popBorderCol) 
  } else {
    floating.pie(i, sampTimes[i], c(inbrCoeff[i], 1-inbrCoeff[i]), radius = curRadius, 
                 col=c(inbreedColor,curColor), startpos=pi, border=popBorderCol)    
  }
  if (sampTimes[i]>0) {
    text(i, sampTimes[i]-curRadius*aspRatio, labels=sampTimes[i], cex=timeProp, col=oldSampColor, pos=1)
  }
  #Draw a vertical arrow in case of pop growth
  curGrowthRate=growthRates[i]
  
  #--- Draw gtrowing or shrinking triangle on top of pop circle to reflect growth type
  if (curGrowthRate!=0) {
    arLength=0.15
    topOfCircle[i]=drawTriangle(curGrowthRate, x=i, y=topOfCircle[i], arLength, aspRatio, color=growthCol)
  }
}

#--- Handle first migration matrix .......................
curMigMatNum=0
curvature=0.0075*last.he.time
text(0-migrOffset, 0, labels=0, cex=migMatNameProp, col=migrMatCol)
if (numMigMat) {
  curMigMat=migMats[1][[1]]
  for (sink in 1:numSamples) {
    for (sourc in 1:numSamples) {
      if (sink!=sourc & curMigMat[sourc, sink]>0)  {
        differ=sourc-sink
        curvedarrow(from=c(sourc, 0), to=c(sink,0), curve=curvature*(abs(differ)*0.55^abs(differ)), arr.adj=1, 
                    arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY, 
                    lcol=migrMatCol, arr.length=arrowLength)   
        if (plotMigrRates) {
          curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)        
          if (differ>0) {
            text(sink+abs(differ)/2, aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
          } else {
            text(sourc+abs(differ)/2, -aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
          } 
        }
      }
    }
  }
}

#---Draw all events on the population tree
lastTime=0
activePops=1:numSamples
numActivePops=numSamples
lastSink=-1
if (numHistEvents) {
  for (i in 1:numHistEvents) {
    #Extract historical event
    he=histEvents[i,]
    he.time=he[1]
    he.source=he[2]+1 #+1 is due to the use of base 0 for deme number in fsc
    he.sink=he[3]+1
    he.migr=he[4]
    he.resize=he[5]
    he.growth=he[6]
    if(he.growth==-9999) { #handle transformed keep keyword
      he.growth=growthRates[he.sink] #Keep current growth rate
    }
    he.migrMat=he[7]
    
    if(he.migrMat==-9999) { #handle transformed keep keyword
      he.migrMat=curMigMatNum
    }
    
    #-- Draw event time
    if (i%%2) {
      slide=timeOffset
    }
    else {
      slide=-timeOffset
    }
    
    #Draw all vertical segments ....................
    for (p in 1:length(activePops)) {
      #Handle population with older sampling times
      if (sampTimes[activePops[p]]>0) {
        minTime=max(lastTime, topOfCircle[activePops[p]]);
      } else {
        minTime=lastTime;
      }
      if (he.time>sampTimes[activePops[p]] & he.time>topOfCircle[activePops[p]]) {
        if (activePops[p]==lastSink | i==1) {
          segments(activePops[p], topOfCircle[activePops[p]], activePops[p], he.time)    
        } else {
          segments(activePops[p], minTime, activePops[p], he.time)        
        }
      }
    }     
    
    #Handle growth rate changes since last event ......................
    #Update pop sizes according to current growth rates
    if (i>1) {
      prev.he=histEvents[i-1,] 
      branchLength=he.time-lastTime
      for (p in 1:length(activePops)) {
        curPop=activePops[p]
        popSizes[curPop]=popSizes[curPop]*exp(growthRates[curPop]*branchLength);
      }
    }
    #Update growth rate
    growthRates[he.sink]=he.growth
    
    
    lastTime=he.time
    #Handle resize of sink pop ........................
    popSizes[he.sink]=popSizes[he.sink]*he.resize
    
    curRadius=interpolRadius(popSizes[he.sink], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
    #     popRadius[he.sink]=curRadius
    topOfCircle[he.sink]=he.time+curRadius*aspRatio
    draw.circle(he.sink, he.time, radius = curRadius, col=popCol, border=popBorderCol)
    
    
    #--- Draw growing or shrinking triangle on top of pop circle to reflect growth type
    if (he.growth!=0) {
      arLength=0.15
      topOfCircle[he.sink]=drawTriangle(he.growth, x=he.sink, y=topOfCircle[he.sink], arLength, aspRatio, color=growthCol)
    }
    
    #Handle population fusion .........................
    if (he.migr>=1 & he.sink!=he.source) { #This is a population fusion
      if (numActivePops==numSamples) removedPops=he.source else removedPops=c(removedPops, he.source)
      numActivePops=numActivePops-1
      activePops=(1:numSamples)[-removedPops]
      #Draw connecting arrows from source to sink
      fullHeadArrow(he.source, he.time, he.sink, he.time, length=0.15, angle=20)      
      #Redraw time with the right color
      text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=popFusionColor)
    } else {
      #--- Handle admixture event ........................
      if (he.migr>0 & he.migr<1) { 
        #Draw connecting arrows from source to sink      
        segments(he.source, he.time, he.sink, he.time, col=admixCol, lty=2)
        if (he.sink>he.source) {
          fullHeadArrow(he.sink-0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
        } else {
          fullHeadArrow(he.sink+0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
        }     
        #Redraw time with the right color
        text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=admixCol)
      }
      else text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=timeCol)
    }    
    
    
    #--- Handle migmat change  ............................
    if (i!=numHistEvents) nextTime=histEvents[i+1,1] else {
      nextTime=yTimeLimit
    }
    time2DrawArrows=(he.time+nextTime)/2
    
    if (he.migrMat!=curMigMatNum) {
      if (he.migrMat>-1) {
        curMigMat=migMats[he.migrMat+1][[1]]
        for (sink in 1:numSamples) {
          for (sourc in 1:numSamples) {
            if (sink!=sourc & curMigMat[sourc, sink]>0)  {  
              differ=sourc-sink
              curvedarrow(from=c(sourc, time2DrawArrows), to=c(sink, time2DrawArrows), curve=curvature*(abs(differ)*0.55^abs(differ)), 
                          arr.adj=1, arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY, 
                          lcol=migrMatCol, arr.length=arrowLength)  
              if (plotMigrRates) {
                #Write Nm values
                curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)
                if (differ>0) {
                  text(sink+abs(differ)/2, time2DrawArrows+aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
                } else {
                  text(sourc+abs(differ)/2, time2DrawArrows-aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
                } 
              }
            }
          }
          # curMigMatNum=he.migrMat
        }
      } 
      #--- Draw separation between migration matrices numbers on the left
      segments(-migMatLineLength/2, he.time, migMatLineLength/2, he.time, lty=3, col=migrMatCol)
    } 
    curMigMatNum=he.migrMat
    
    #Output current valid migration matrix      
    if (i%%2) {
      slide=migrOffset
    }
    else {
      slide=-migrOffset
    }   
    if (he.migrMat>-1) {
      migText=he.migrMat
      curCex=migMatNameProp
    } else {
      migText="nomig"
      curCex=migMatNameProp/2
      slide=slide*2
    }
    text(0+slide, time2DrawArrows, labels=migText, cex=curCex, col=migrMatCol)    
    
    lastSink=he.sink
  }
}

#-- Draw last branch
segments(activePops[1],topOfCircle[activePops[1]], activePops[1], yTimeLimit)

#==============================   PLOT LEGENDS IN MARGINS   ========================

#Compute space available in margin
minY.coo=grconvertY(0, from="nic", to="user")

par(xpd=NA)
#--- Draw population size scale with circles of different sizes .................
maxOrder=ceiling(log10(maxPopSize))
minOrder=floor(log10(minPopSize))
popSizeRadius=10^(maxOrder:minOrder)
winWidth=numSamples+2
ypos=3/4*minY.coo
text(x=-winWidth/10*1.2, y=ypos, labels="Pop. \nsizes ", cex=.8, pos=2)

for (i in 1:length(popSizeRadius)) {
  curRadius=interpolRadius(popSizeRadius[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
  #   print(curRadius)
  if (curRadius>0) {
    xpos=-winWidth/10+(i-1)*winWidth/10
    draw.circle(xpos, ypos, radius=curRadius, col=popCol, border=popBorderCol)
  }
  text(xpos, ypos-abs(ypos)*0.1, popSizeRadius[i], cex=0.7, pos=1, col="black")
}

#--- Legend for growing or shrinking populations ...............................
if (isGrowth) {
  x=winWidth-1.5*winWidth/10; y=ypos+abs(ypos)*0.2
  text(x, y-abs(ypos)*0.1, labels="Populations", cex=0.8)
  x=winWidth-2*winWidth/10; y=ypos-abs(ypos)*0.1
  drawTriangle(1, x, y, size=0.15, aspRatio, color=growthCol)
  text(x, y-abs(ypos)*0.1, labels="growing", pos=NULL, cex=0.7)
  x=winWidth-winWidth/10
  drawTriangle(-1, x, y, size=0.15, aspRatio, color=growthCol)
  text(x, y-abs(ypos)*0.1, labels="shrinking", pos=NULL, cex=0.7)  
}


#if (printPDF) dev.off()
dev.off()
```

## _Varroa jacobsoni_ demographic history

The same process described for _V. destructor_ demographic history inferences was independently applied for its sister species _V. jacobsoni_.

## Likelihood distribution for the four VJ SFS datasets

Contrary to _V. destructor_ for which the scenario 6 was undeniably the most likely according to both AIC and model likelihood distribution, both scenarios 3 and 6 seems likely in the case of recent host switch by _V. jacobsoni_.

As a consequence, we repeated the same process of bootstraps computations as done for _V. destructor_ but for both scenarios: DIV + BOT and IM + BOT.

```{r lhoodsvj, message = FALSE, warning = FALSE, cache = "TRUE"}

vj.lhoods1050 <- read.csv("fsc_run/lhoods_1050SNPS_vjpng.csv", header = TRUE)
vj.lhoods10500 <- read.csv("fsc_run/lhoods_10500SNPS_vjpng.csv", header = TRUE)
vj.lhoods35000 <- read.csv("fsc_run/lhoods_35000SNPS_vjpng.csv", header = TRUE)
vj.lhoods105000 <- read.csv("fsc_run/lhoods_105000SNPS_vjpng.csv", header = TRUE)

par(mfrow=c(1,4))
#Plot 1 for likelihoods with smaller subset
boxplot(range = 0,vj.lhoods1050$scenario1_div [3:102], vj.lhoods1050$scenario2_divGwt2n[3:102], vj.lhoods1050$scenario3_divGwt[3:102], vj.lhoods1050$scenario4_IM[3:102], vj.lhoods1050$scenario5_IMGwt2n[3:102], vj.lhoods1050$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vj.lhoods1050$scenario1_div [2],col = "blue", pch = 20)
points(2,vj.lhoods1050$scenario2_divGwt2n [2],col = "blue", pch = 20)
points(3,vj.lhoods1050$scenario3_divGwt [2],col = "blue", pch = 20)
points(4,vj.lhoods1050$scenario4_IM [2],col = "blue", pch = 20)
points(5,vj.lhoods1050$scenario5_IMGwt2n [2],col = "blue", pch = 20)
points(6,vj.lhoods1050$scenario6_IMGwt [2],col = "blue", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. jacobsoni 472 SNPS")

#Plot 2 for likelihoods with second smaller subset
boxplot(range = 0,vj.lhoods10500$scenario1_div [3:102], vj.lhoods10500$scenario2_divGwt2n[3:102], vj.lhoods10500$scenario3_divGwt[3:102], vj.lhoods10500$scenario4_IM[3:102], vj.lhoods10500$scenario5_IMGwt2n[3:102], vj.lhoods10500$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vj.lhoods10500$scenario1_div [2],col = "blue", pch = 20)
points(2,vj.lhoods10500$scenario2_divGwt2n [2],col = "blue", pch = 20)
points(3,vj.lhoods10500$scenario3_divGwt [2],col = "blue", pch = 20)
points(4,vj.lhoods10500$scenario4_IM [2],col = "blue", pch = 20)
points(5,vj.lhoods10500$scenario5_IMGwt2n [2],col = "blue", pch = 20)
points(6,vj.lhoods10500$scenario6_IMGwt [2],col = "blue", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. jacobsoni 4,713 SNPS")

#Plot 3 for likelihoods with third subset
boxplot(range = 0,vj.lhoods35000$scenario1_div [3:102], vj.lhoods35000$scenario2_divGwt2n[3:102], vj.lhoods35000$scenario3_divGwt[3:102], vj.lhoods35000$scenario4_IM[3:102], vj.lhoods35000$scenario5_IMGwt2n[3:102], vj.lhoods35000$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vj.lhoods35000$scenario1_div [2],col = "blue", pch = 20)
points(2,vj.lhoods35000$scenario2_divGwt2n [2],col = "blue", pch = 20)
points(3,vj.lhoods35000$scenario3_divGwt [2],col = "blue", pch = 20)
points(4,vj.lhoods35000$scenario4_IM [2],col = "blue", pch = 20)
points(5,vj.lhoods35000$scenario5_IMGwt2n [2],col = "blue", pch = 20)
points(6,vj.lhoods35000$scenario6_IMGwt [2],col = "blue", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. jacobsoni 15,363 SNPS")

#Plot 4 for likelihoods with larger subset
boxplot(range = 0,vj.lhoods105000$scenario1_div [3:102], vj.lhoods105000$scenario2_divGwt2n[3:102], vj.lhoods105000$scenario3_divGwt[3:102], vj.lhoods105000$scenario4_IM[3:102], vj.lhoods105000$scenario5_IMGwt2n[3:102], vj.lhoods105000$scenario6_IMGwt[3:102], ylab="log 10 Likelihood",xaxt="n")
points(1,vj.lhoods105000$scenario1_div [2],col = "blue", pch = 20)
points(2,vj.lhoods105000$scenario2_divGwt2n [2],col = "blue", pch = 20)
points(3,vj.lhoods105000$scenario3_divGwt [2],col = "blue", pch = 20)
points(4,vj.lhoods105000$scenario4_IM [2],col = "blue", pch = 20)
points(5,vj.lhoods105000$scenario5_IMGwt2n [2],col = "blue", pch = 20)
points(6,vj.lhoods105000$scenario6_IMGwt [2],col = "blue", pch = 20)
axis(side=1,at=1:6, labels=c("DIV1","DIV2","DIV3","IM4","IM5","IM6"))
title("V. jacobsoni 46,416 SNPS")
```

## Scenario 3: DIV + BOT bootstraps computation
```{r vjboot3, message = FALSE, warning = FALSE, cache = "TRUE"}

# import the file containing the 100 best runs
vj.boot3 <- read.csv("fsc_run/png_105000nopv_scen3_BOOT.csv", header = TRUE)

# Effective size for Varroa mites on original host Apis cerana
N_VjAc1.boot = boot(vj.boot3$NVJAC1, my.mean, 10000)
my.mean(vj.boot3$NVJAC1,1:length(vj.boot3$NVJAC1))
boot.ci(N_VjAc1.boot)

# Effective size for Varroa mites on new host Apis mellifera
N_VjAm0.boot = boot(vj.boot3$NVJAM0, my.mean, 10000)
my.mean(vj.boot3$NVJAM0,1:length(vj.boot3$NVJAM0))
boot.ci(N_VjAm0.boot)

# Number of generations when new population of Varroa mites was founded
TBOT.boot = boot(vj.boot3$TBOT, my.mean, 10000)
my.mean(vj.boot3$TBOT,1:length(vj.boot3$TBOT))
boot.ci(TBOT.boot)

# Growth rate of Varroa mites on new host Apis mellifera
GAM.boot = boot(vj.boot3$GAM, my.mean, 10000)
my.mean(vj.boot3$GAM,1:length(vj.boot3$GAM))
boot.ci(GAM.boot)

# Effective size for Varroa mites able to jump on A. mellifera to create new population
JUMP.boot = boot(vj.boot3$JUMP, my.mean, 10000)
my.mean(vj.boot3$JUMP,1:length(vj.boot3$JUMP))
boot.ci(JUMP.boot)

```

## Draw parameters for scenario 3 with mean bootstraps
```{r sousaexcoffierdrawvj3, message = FALSE, warning = FALSE, cache = "TRUE"}
#...........................................................................................
# (c) Laurent Excoffier and Vitor Sousa June-November 2015
# 
# Small R program to draw the evolutonary scenario described by a given par file
# This is mainly for visual checking that the modeled scenario corresponds to   
# what was intended
#
#...........................................................................................
#
args=commandArgs(TRUE)
print(args)

#Expects par file name on command line

if(length(args)) {
  parFileName=args[1]
} else {  
  #REPLACE BY THE NAME OF THE PAR FILE YOU WANT TO ANALYSE
  parFileName="fsc_run/VJM3_downsample_divGwt_29_boot.par"
}

separator=" "
migrMatCol="coral"
admixCol="blue"
popFusionColor="black"
popCol="lightgrey"
popBorderCol="black"
inbreedColor="lightblue"
oldSampColor="olivedrab4"
timeCol="tan4"
growthCol="hotpink3"
propLastsegment=0.05
migMatNameProp=0.8
migMatLineLength=0.3
timeProp=0.6
maxRadius=1/40
minRadius=maxRadius/3
arrowLength=0.2
logScaleAxis=""
timeOffset=0.25
migrOffset=0.1
curvedArrowLTY=1
drawLogPopSize=T
plotMigrRates=T
migrRateTextSizeCEX=0.5

#Define plot area size for PDF
pdf.x.size=7
pdf.y.size=10

rescalingFactor=1.0 #Don't touch this!


printPDF=F

# parFile=readLines(con=parFileName)

###########################      Reading par file      #########################

parFile=scan(parFileName, character(0), sep = "\n", strip.white = TRUE) # separate each line

pdfFileName=paste(parFileName, ".pdf", sep="")

#--- Clean input file by removing consecutive separators, and keep ---------------

#--- Function to remove separators within a string
removeTrailingSep=function(string, sep) {
  temp=strsplit(string, split=sep)
  temp2=temp[[1]][nchar(temp[[1]])>0]
  cleanStr=temp2[1]
  if (length(temp2)>1) {
    for (i in 2:length(temp2)) {
      cleanStr=paste(cleanStr, temp2[i], sep=sep)
    }
  }
  cleanStr
}

#--- Replace Keep by -9999
replaceKeep=function(string) {
  if (grepl("keep", string)) {
    return(gsub("keep", "-9999", string))
  }
  return(string)
}

#Remove both multiple consecutive whitespace and tabs and replace keep keyword
for (i in 1:length(parFile)) {
  parFile[i]=removeTrailingSep(parFile[i], sep='\t')
  parFile[i]=removeTrailingSep(parFile[i], sep=' ')
  parFile[i]=replaceKeep(parFile[i])
}

#-------------------------------------------------------------------------------

#--- Get number of samples on line 2 -----
l.numsamples=parFile[2]
sp.l=unlist(strsplit(l.numsamples, split=' '))
tab.l=unlist(strsplit(l.numsamples, split='\t'))
if (length(sp.l)>=length(tab.l)) {
  numSamples=as.numeric(sp.l[1])
  separator=" "
} else {
  numSamples=as.numeric(tab.l[1])
  separator="\t"
}

#--- Reading numbers on separate lines -----
getNumbers=function(start, parFile, numSamples) {  
  for (i in 1:numSamples) {
    curnum=as.numeric(unlist(strsplit(parFile[start+i], split=separator))[1])
    if (i==1) {
      num=curnum 
    } else {
      num=c(num, curnum)
    }
  }
  num
}

#--- Get population sizes -----------------
start=3
popSizes=getNumbers(start, parFile, numSamples)
#Rescaling pop sizes
popSizes=round(popSizes*rescalingFactor, digits=0)

iniPopSizes=popSizes

#--- Get sample sizes -----------------

readSampleSizesTimesAndInbreedingLevel=function(start, parFile, numSamples) {
  for (i in 1:numSamples) {
    curLine=unlist(strsplit(parFile[start+i], split=separator))
    curSampSize=as.numeric(curLine[1])
    curSampTime=0
    curInbreeding=0
    if (length(curLine)>1) curSampTime=as.numeric(curLine[2])
    if (length(curLine)>2) curInbreeding=as.numeric(curLine[3])
    if (i==1) {
      sampSize=curSampSize
      sampTime=curSampTime
      inbreeding=curInbreeding
    } else {
      sampSize=c(sampSize,curSampSize)
      sampTime=c(sampTime,curSampTime)
      inbreeding=c(inbreeding,curInbreeding)
    }
  }
  list(ss=sampSize, st=sampTime, inb=inbreeding)
}

start=start+numSamples+1
# sampSizes=getNumbers(start, parFile, numSamples)
sampSizesStats=readSampleSizesTimesAndInbreedingLevel(start, parFile, numSamples)
#Rescaling sample times
sampSizesStats$st=round(sampSizesStats$st*rescalingFactor, digits=0)

sampSizes=sampSizesStats$ss
sampTimes=sampSizesStats$st
inbrCoeff=sampSizesStats$inb

#--- Get growth rates -----------------
start=start+numSamples+1
growthRatesInitial=getNumbers(start, parFile, numSamples)
# save this into growthRates which will be used and updated when printing historical events
growthRates=growthRatesInitial

#--- Get number of migration matrices -----------------
start=start+numSamples+1
numMigMat=as.numeric(unlist(strsplit(parFile[start+1], split=separator))[1])

#--- Read migration matrix
readMigMat=function(start, parFile, numSamples) {
  for (i in 1:numSamples) {
    curmigs=as.numeric(unlist(strsplit(parFile[start+i], split=separator)))
    if (i==1) {
      migs=curmigs 
    } else {
      migs=rbind(migs, curmigs)
    }
  }
  rownames(migs)=1:numSamples
  migs 
}

#--- Get migration matrices as a list --------------
start=start+2
migMats=list()
if (numMigMat>0) {
  for (i in 1:numMigMat) {  
    curMigMat=readMigMat(start, parFile, numSamples) 
    migMats[[i]]=curMigMat
    start=start+numSamples+1
  }
}

#Rescaling migration rates
if (numMigMat>0) {
  for (i in 1:numMigMat) {
    migMats[[i]]=migMats[[i]]/rescalingFactor
  }
}

#--- Get number of historical events
start=start+1
numHistEvents=as.numeric(unlist(strsplit(parFile[start], split=separator))[1])

###################### HISTORICAL EVENTS HANDLING ##############################

#..... Read Historical Event .......
last.he.time=0
if (numHistEvents>0) {
  for (i in 1:numHistEvents) {
    start=start+1
    #Take care of nomig keyword
    nomig=F
    if (grepl("nomig", parFile[start])) {
      nomig=T
      gsub("nomig", "", parFile[start])
    }
    curHE=as.numeric(unlist(strsplit(parFile[start], split=separator)))
    if (nomig) curHE[7]=-1 
    #Rescaling time of event
    curHE[1]=round(curHE[1]*rescalingFactor, digits=0)
    if (i==1) {
      histEvents=curHE
      last.he.time=curHE[1]
    } else {
      histEvents=rbind(histEvents, curHE)
      if (histEvents[i,1] > last.he.time) last.he.time=histEvents[i,1] 
    }
  }
  if (numHistEvents>1) rownames(histEvents)=1:numHistEvents
}
names(last.he.time)=""
last.he.time=as.numeric(last.he.time)

yTimeLimit=0
if (last.he.time!=0) yTimeLimit=last.he.time*(1+propLastsegment) #Add propLastsegment to y axis after last event (to draw stuff)

#Reorder events by their times
if (numHistEvents>1) histEvents=histEvents[order(histEvents[,1],decreasing=FALSE),] else {
  if (numHistEvents==1) histEvents=matrix(histEvents, nrow=1,  byrow = T)
}

endReadParFile=start



##############################  PLOTTING THE MODELED SCENARIO ######################################


#--- Graphical functions ...........................................................................

fullHeadArrow=function(x0, y0, x1, y1, length, angle, color="black",  weight=1) {
  arrows(x0, y0, x1, y1, length, angle, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.80, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.60, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.40, code=2, lty=1, col=color, lwd=weight) 
  arrows(x0, y0, x1, y1, length, angle*0.20, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.10, code=2, lty=1, col=color, lwd=weight)
}
drawTriangle=function(growth, x, y, size, aspRatio, color) {
  if (growth>0) {
    x0=x; y0=y
    x1=x-size/2; y1=y+size/2*aspRatio
    x2=x+size/2; y2=y+size/2*aspRatio
  } else {
    x0=x-size/2; y0=y
    x1=x; y1=y+size/2*aspRatio
    x2=x+size/2; y2=y
  }
  polygon(c(x0, x1, x2, x0), c(y0, y1, y2, y0), col=color)
  return(y+size/2*aspRatio)
}


#--- Computing maximum current pop size ............................................................
maxPopSize=popSizes[1]
minPopSize=popSizes[1]
if (length(popSizes)>1){
  for (i in 2:length(popSizes)) {
    if (popSizes[i]>maxPopSize) maxPopSize=popSizes[i];
    if (popSizes[i]<minPopSize) minPopSize=popSizes[i];
  }
}

#--- Find min and max pop sizes over the whole population history ..................................
ps=popSizes
isGrowth=FALSE
if (numHistEvents) {
  #Need to keep track ofgrowth rates over time
  gRates=growthRates
  prevTime=0
  for (i in 1:numHistEvents) {
    he=histEvents[i,]
    curTime=he[1]
    sink=he[3]+1 
    resize=he[5]
    growth=he[6]
    
    #Begin by resizing pop sizes due to growth since last event
    for (j in 1:length(ps)) {
      ps[j]=ps[j]*exp(gRates[j]*(curTime-prevTime))
      if (ps[j]>maxPopSize) maxPopSize=ps[j]
      if (ps[j]<minPopSize) minPopSize=ps[j]
      if (ps[j]==0) print(paste("Deme ", j-1, " reaches size zero at time ",  curTime, " due to large negative growth (", gRates[j], ")", sep=""))
      if (is.infinite(ps[j])) print(paste("Deme ", j-1, " reaches infinite size at time ",  curTime, " due to large positive growth (", gRates[j], ")", sep=""))
    }
    prevTime=curTime
    
    #Handle transformed keep keyword
    if(growth!=-9999) {
      gRates[sink]=growth 
    }
    
    #Implement resize
    ps[sink]=ps[sink]*resize
    if (ps[sink]>maxPopSize) maxPopSize=ps[sink]
    if (ps[sink]<minPopSize) minPopSize=ps[sink]
  }
}

#-- Function to compute the circle radius for a given pop size ....................................
interpolRadius=function(curSize, minSize, maxSize, minRadius, maxRadius, logScale) {
  if(logScale) {
    minSize=log10(minSize)
    maxSize=log10(maxSize)
    curSize=log10(curSize)
  }
  curRadius=minRadius+(curSize-minSize)*(maxRadius-minRadius)/(maxSize-minSize)
  curRadius
}

#==============================                     ========================
#==============================   BEGIN MAIN PLOT   ========================
#==============================                     ========================

library("plotrix")
library("diagram")

if (printPDF) {
  pdf(pdfFileName, width=pdf.x.size, height=pdf.y.size)
} 

par(xpd=F, mar=c(6,4,3,0.5))

maxRadius=maxRadius*(numSamples+2)
minRadius=minRadius*(numSamples+2)

title=parFileName

plot(x=1:numSamples, type="n", xlab="", ylab="time (gen)", xlim=c(-0.5, numSamples+1.5), cex.main=0.8,
     ylim=c(0, yTimeLimit), main=title, xaxt = 'n', log=logScaleAxis, cex.axis=0.9, cex.lab=0.9)
axis(side=1, labels=c("Mig Mat",0:(numSamples-1), " \nTimes"), at=0:(numSamples+1), cex.axis=0.8)
mtext("demes", side=1,line=2, cex=0.8)

w <- par("pin")[1]/diff(par("usr")[1:2])
h <- par("pin")[2]/diff(par("usr")[3:4])
aspRatio <- w/h

# aspRatio=yTimeLimit/(numSamples+2)

#--- Plotting population circles according to their current size and sampling time
for (i in 1:numSamples) {
  curRadius=interpolRadius(popSizes[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
  #   print(curRadius)
  if (i==1) topOfCircle=sampTimes[i]+curRadius*aspRatio else topOfCircle=c(topOfCircle, sampTimes[i]+curRadius*aspRatio)
  curColor=popCol
  if (sampSizes[i]==0) curColor="white"
  if (inbrCoeff[i]==0) {
    draw.circle(i, sampTimes[i], radius = curRadius, col=curColor, border=popBorderCol) 
  } else {
    floating.pie(i, sampTimes[i], c(inbrCoeff[i], 1-inbrCoeff[i]), radius = curRadius, 
                 col=c(inbreedColor,curColor), startpos=pi, border=popBorderCol)    
  }
  if (sampTimes[i]>0) {
    text(i, sampTimes[i]-curRadius*aspRatio, labels=sampTimes[i], cex=timeProp, col=oldSampColor, pos=1)
  }
  #Draw a vertical arrow in case of pop growth
  curGrowthRate=growthRates[i]
  
  #--- Draw gtrowing or shrinking triangle on top of pop circle to reflect growth type
  if (curGrowthRate!=0) {
    arLength=0.15
    topOfCircle[i]=drawTriangle(curGrowthRate, x=i, y=topOfCircle[i], arLength, aspRatio, color=growthCol)
  }
}

#--- Handle first migration matrix .......................
curMigMatNum=0
curvature=0.0075*last.he.time
text(0-migrOffset, 0, labels=0, cex=migMatNameProp, col=migrMatCol)
if (numMigMat) {
  curMigMat=migMats[1][[1]]
  for (sink in 1:numSamples) {
    for (sourc in 1:numSamples) {
      if (sink!=sourc & curMigMat[sourc, sink]>0)  {
        differ=sourc-sink
        curvedarrow(from=c(sourc, 0), to=c(sink,0), curve=curvature*(abs(differ)*0.55^abs(differ)), arr.adj=1, 
                    arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY, 
                    lcol=migrMatCol, arr.length=arrowLength)   
        if (plotMigrRates) {
          curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)        
          if (differ>0) {
            text(sink+abs(differ)/2, aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
          } else {
            text(sourc+abs(differ)/2, -aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
          } 
        }
      }
    }
  }
}

#---Draw all events on the population tree
lastTime=0
activePops=1:numSamples
numActivePops=numSamples
lastSink=-1
if (numHistEvents) {
  for (i in 1:numHistEvents) {
    #Extract historical event
    he=histEvents[i,]
    he.time=he[1]
    he.source=he[2]+1 #+1 is due to the use of base 0 for deme number in fsc
    he.sink=he[3]+1
    he.migr=he[4]
    he.resize=he[5]
    he.growth=he[6]
    if(he.growth==-9999) { #handle transformed keep keyword
      he.growth=growthRates[he.sink] #Keep current growth rate
    }
    he.migrMat=he[7]
    
    if(he.migrMat==-9999) { #handle transformed keep keyword
      he.migrMat=curMigMatNum
    }
    
    #-- Draw event time
    if (i%%2) {
      slide=timeOffset
    }
    else {
      slide=-timeOffset
    }
    
    #Draw all vertical segments ....................
    for (p in 1:length(activePops)) {
      #Handle population with older sampling times
      if (sampTimes[activePops[p]]>0) {
        minTime=max(lastTime, topOfCircle[activePops[p]]);
      } else {
        minTime=lastTime;
      }
      if (he.time>sampTimes[activePops[p]] & he.time>topOfCircle[activePops[p]]) {
        if (activePops[p]==lastSink | i==1) {
          segments(activePops[p], topOfCircle[activePops[p]], activePops[p], he.time)    
        } else {
          segments(activePops[p], minTime, activePops[p], he.time)        
        }
      }
    }     
    
    #Handle growth rate changes since last event ......................
    #Update pop sizes according to current growth rates
    if (i>1) {
      prev.he=histEvents[i-1,] 
      branchLength=he.time-lastTime
      for (p in 1:length(activePops)) {
        curPop=activePops[p]
        popSizes[curPop]=popSizes[curPop]*exp(growthRates[curPop]*branchLength);
      }
    }
    #Update growth rate
    growthRates[he.sink]=he.growth
    
    
    lastTime=he.time
    #Handle resize of sink pop ........................
    popSizes[he.sink]=popSizes[he.sink]*he.resize
    
    curRadius=interpolRadius(popSizes[he.sink], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
    #     popRadius[he.sink]=curRadius
    topOfCircle[he.sink]=he.time+curRadius*aspRatio
    draw.circle(he.sink, he.time, radius = curRadius, col=popCol, border=popBorderCol)
    
    
    #--- Draw growing or shrinking triangle on top of pop circle to reflect growth type
    if (he.growth!=0) {
      arLength=0.15
      topOfCircle[he.sink]=drawTriangle(he.growth, x=he.sink, y=topOfCircle[he.sink], arLength, aspRatio, color=growthCol)
    }
    
    #Handle population fusion .........................
    if (he.migr>=1 & he.sink!=he.source) { #This is a population fusion
      if (numActivePops==numSamples) removedPops=he.source else removedPops=c(removedPops, he.source)
      numActivePops=numActivePops-1
      activePops=(1:numSamples)[-removedPops]
      #Draw connecting arrows from source to sink
      fullHeadArrow(he.source, he.time, he.sink, he.time, length=0.15, angle=20)      
      #Redraw time with the right color
      text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=popFusionColor)
    } else {
      #--- Handle admixture event ........................
      if (he.migr>0 & he.migr<1) { 
        #Draw connecting arrows from source to sink      
        segments(he.source, he.time, he.sink, he.time, col=admixCol, lty=2)
        if (he.sink>he.source) {
          fullHeadArrow(he.sink-0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
        } else {
          fullHeadArrow(he.sink+0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
        }     
        #Redraw time with the right color
        text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=admixCol)
      }
      else text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=timeCol)
    }    
    
    
    #--- Handle migmat change  ............................
    if (i!=numHistEvents) nextTime=histEvents[i+1,1] else {
      nextTime=yTimeLimit
    }
    time2DrawArrows=(he.time+nextTime)/2
    
    if (he.migrMat!=curMigMatNum) {
      if (he.migrMat>-1) {
        curMigMat=migMats[he.migrMat+1][[1]]
        for (sink in 1:numSamples) {
          for (sourc in 1:numSamples) {
            if (sink!=sourc & curMigMat[sourc, sink]>0)  {  
              differ=sourc-sink
              curvedarrow(from=c(sourc, time2DrawArrows), to=c(sink, time2DrawArrows), curve=curvature*(abs(differ)*0.55^abs(differ)), 
                          arr.adj=1, arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY, 
                          lcol=migrMatCol, arr.length=arrowLength)  
              if (plotMigrRates) {
                #Write Nm values
                curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)
                if (differ>0) {
                  text(sink+abs(differ)/2, time2DrawArrows+aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
                } else {
                  text(sourc+abs(differ)/2, time2DrawArrows-aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
                } 
              }
            }
          }
          # curMigMatNum=he.migrMat
        }
      } 
      #--- Draw separation between migration matrices numbers on the left
      segments(-migMatLineLength/2, he.time, migMatLineLength/2, he.time, lty=3, col=migrMatCol)
    } 
    curMigMatNum=he.migrMat
    
    #Output current valid migration matrix      
    if (i%%2) {
      slide=migrOffset
    }
    else {
      slide=-migrOffset
    }   
    if (he.migrMat>-1) {
      migText=he.migrMat
      curCex=migMatNameProp
    } else {
      migText="nomig"
      curCex=migMatNameProp/2
      slide=slide*2
    }
    text(0+slide, time2DrawArrows, labels=migText, cex=curCex, col=migrMatCol)    
    
    lastSink=he.sink
  }
}

#-- Draw last branch
segments(activePops[1],topOfCircle[activePops[1]], activePops[1], yTimeLimit)

#==============================   PLOT LEGENDS IN MARGINS   ========================

#Compute space available in margin
minY.coo=grconvertY(0, from="nic", to="user")

par(xpd=NA)
#--- Draw population size scale with circles of different sizes .................
maxOrder=ceiling(log10(maxPopSize))
minOrder=floor(log10(minPopSize))
popSizeRadius=10^(maxOrder:minOrder)
winWidth=numSamples+2
ypos=3/4*minY.coo
text(x=-winWidth/10*1.2, y=ypos, labels="Pop. \nsizes ", cex=.8, pos=2)

for (i in 1:length(popSizeRadius)) {
  curRadius=interpolRadius(popSizeRadius[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
  #   print(curRadius)
  if (curRadius>0) {
    xpos=-winWidth/10+(i-1)*winWidth/10
    draw.circle(xpos, ypos, radius=curRadius, col=popCol, border=popBorderCol)
  }
  text(xpos, ypos-abs(ypos)*0.1, popSizeRadius[i], cex=0.7, pos=1, col="black")
}

#--- Legend for growing or shrinking populations ...............................
if (isGrowth) {
  x=winWidth-1.5*winWidth/10; y=ypos+abs(ypos)*0.2
  text(x, y-abs(ypos)*0.1, labels="Populations", cex=0.8)
  x=winWidth-2*winWidth/10; y=ypos-abs(ypos)*0.1
  drawTriangle(1, x, y, size=0.15, aspRatio, color=growthCol)
  text(x, y-abs(ypos)*0.1, labels="growing", pos=NULL, cex=0.7)
  x=winWidth-winWidth/10
  drawTriangle(-1, x, y, size=0.15, aspRatio, color=growthCol)
  text(x, y-abs(ypos)*0.1, labels="shrinking", pos=NULL, cex=0.7)  
}


#if (printPDF) dev.off()
dev.off()
```

## Scenario 6: IM + BOT bootstraps computation
```{r vjboot6, message = FALSE, warning = FALSE, cache = "TRUE"}

# import the file containing the 100 best runs
vj.boot6 <- read.csv("fsc_run/png_105000nopv_scen6_BOOT.csv", header = TRUE)

# Effective size for Varroa mites on original host Apis cerana
N_VjAc1.boot = boot(vj.boot6$NVJAC1, my.mean, 10000)
my.mean(vj.boot6$NVJAC1,1:length(vj.boot6$NVJAC1))
boot.ci(N_VjAc1.boot)

# Effective size for Varroa mites on new host Apis mellifera
N_VjAm0.boot = boot(vj.boot6$NVJAM0, my.mean, 10000)
my.mean(vj.boot6$NVJAM0,1:length(vj.boot6$NVJAM0))
boot.ci(N_VjAm0.boot)

# Number of generations when new population of Varroa mites was founded
TBOT.boot = boot(vj.boot6$TBOT, my.mean, 10000)
my.mean(vj.boot6$TBOT,1:length(vj.boot6$TBOT))
boot.ci(TBOT.boot)

# Growth rate of Varroa mites on new host Apis mellifera
GAM.boot = boot(vj.boot6$GAM, my.mean, 10000)
my.mean(vj.boot6$GAM,1:length(vj.boot6$GAM))
boot.ci(GAM.boot)

# Effective size for Varroa mites able to jump on A. mellifera to create new population
JUMP.boot = boot(vj.boot6$JUMP, my.mean, 10000)
my.mean(vj.boot6$JUMP,1:length(vj.boot6$JUMP))
boot.ci(JUMP.boot)

N0M1.boot = boot(vj.boot6$N0M1, my.mean, 10000)
my.mean(vj.boot6$N0M1,1:length(vj.boot6$N0M1))
boot.ci(N0M1.boot)

N1M0.boot = boot(vj.boot6$N1M0, my.mean, 10000)
my.mean(vj.boot6$N1M0,1:length(vj.boot6$N1M0))
boot.ci(N1M0.boot)

MACtoAM.boot = boot(vj.boot6$MACtoAM, my.mean, 10000)
my.mean(vj.boot6$MACtoAM,1:length(vj.boot6$MACtoAM))
boot.ci(MACtoAM.boot)

MAMtoAC.boot = boot(vj.boot6$MAMtoAC, my.mean, 10000)
my.mean(vj.boot6$MAMtoAC,1:length(vj.boot6$MAMtoAC))
boot.ci(MAMtoAC.boot)
```

## Draw parameters for scenario 6 with mean bootstraps
```{r sousaexcoffierdrawvj, warning = FALSE, cache = "TRUE"}
#...........................................................................................
# (c) Laurent Excoffier and Vitor Sousa June-November 2015
# 
# Small R program to draw the evolutonary scenario described by a given par file
# This is mainly for visual checking that the modeled scenario corresponds to   
# what was intended
#
#...........................................................................................
#
args=commandArgs(TRUE)
print(args)

#Expects par file name on command line

if(length(args)) {
  parFileName=args[1]
} else {  
  #REPLACE BY THE NAME OF THE PAR FILE YOU WANT TO ANALYSE
  parFileName="fsc_run/VJM6_downsample_IMGwt_32_boot.par"
}

separator=" "
migrMatCol="coral"
admixCol="blue"
popFusionColor="black"
popCol="lightgrey"
popBorderCol="black"
inbreedColor="lightblue"
oldSampColor="olivedrab4"
timeCol="tan4"
growthCol="hotpink3"
propLastsegment=0.05
migMatNameProp=0.8
migMatLineLength=0.3
timeProp=0.6
maxRadius=1/40
minRadius=maxRadius/3
arrowLength=0.2
logScaleAxis=""
timeOffset=0.25
migrOffset=0.1
curvedArrowLTY=1
drawLogPopSize=T
plotMigrRates=T
migrRateTextSizeCEX=0.5

#Define plot area size for PDF
pdf.x.size=7
pdf.y.size=10

rescalingFactor=1.0 #Don't touch this!


printPDF=F

# parFile=readLines(con=parFileName)

###########################      Reading par file      #########################

parFile=scan(parFileName, character(0), sep = "\n", strip.white = TRUE) # separate each line

pdfFileName=paste(parFileName, ".pdf", sep="")

#--- Clean input file by removing consecutive separators, and keep ---------------

#--- Function to remove separators within a string
removeTrailingSep=function(string, sep) {
  temp=strsplit(string, split=sep)
  temp2=temp[[1]][nchar(temp[[1]])>0]
  cleanStr=temp2[1]
  if (length(temp2)>1) {
    for (i in 2:length(temp2)) {
      cleanStr=paste(cleanStr, temp2[i], sep=sep)
    }
  }
  cleanStr
}

#--- Replace Keep by -9999
replaceKeep=function(string) {
  if (grepl("keep", string)) {
    return(gsub("keep", "-9999", string))
  }
  return(string)
}

#Remove both multiple consecutive whitespace and tabs and replace keep keyword
for (i in 1:length(parFile)) {
  parFile[i]=removeTrailingSep(parFile[i], sep='\t')
  parFile[i]=removeTrailingSep(parFile[i], sep=' ')
  parFile[i]=replaceKeep(parFile[i])
}

#-------------------------------------------------------------------------------

#--- Get number of samples on line 2 -----
l.numsamples=parFile[2]
sp.l=unlist(strsplit(l.numsamples, split=' '))
tab.l=unlist(strsplit(l.numsamples, split='\t'))
if (length(sp.l)>=length(tab.l)) {
  numSamples=as.numeric(sp.l[1])
  separator=" "
} else {
  numSamples=as.numeric(tab.l[1])
  separator="\t"
}

#--- Reading numbers on separate lines -----
getNumbers=function(start, parFile, numSamples) {  
  for (i in 1:numSamples) {
    curnum=as.numeric(unlist(strsplit(parFile[start+i], split=separator))[1])
    if (i==1) {
      num=curnum 
    } else {
      num=c(num, curnum)
    }
  }
  num
}

#--- Get population sizes -----------------
start=3
popSizes=getNumbers(start, parFile, numSamples)
#Rescaling pop sizes
popSizes=round(popSizes*rescalingFactor, digits=0)

iniPopSizes=popSizes

#--- Get sample sizes -----------------

readSampleSizesTimesAndInbreedingLevel=function(start, parFile, numSamples) {
  for (i in 1:numSamples) {
    curLine=unlist(strsplit(parFile[start+i], split=separator))
    curSampSize=as.numeric(curLine[1])
    curSampTime=0
    curInbreeding=0
    if (length(curLine)>1) curSampTime=as.numeric(curLine[2])
    if (length(curLine)>2) curInbreeding=as.numeric(curLine[3])
    if (i==1) {
      sampSize=curSampSize
      sampTime=curSampTime
      inbreeding=curInbreeding
    } else {
      sampSize=c(sampSize,curSampSize)
      sampTime=c(sampTime,curSampTime)
      inbreeding=c(inbreeding,curInbreeding)
    }
  }
  list(ss=sampSize, st=sampTime, inb=inbreeding)
}

start=start+numSamples+1
# sampSizes=getNumbers(start, parFile, numSamples)
sampSizesStats=readSampleSizesTimesAndInbreedingLevel(start, parFile, numSamples)
#Rescaling sample times
sampSizesStats$st=round(sampSizesStats$st*rescalingFactor, digits=0)

sampSizes=sampSizesStats$ss
sampTimes=sampSizesStats$st
inbrCoeff=sampSizesStats$inb

#--- Get growth rates -----------------
start=start+numSamples+1
growthRatesInitial=getNumbers(start, parFile, numSamples)
# save this into growthRates which will be used and updated when printing historical events
growthRates=growthRatesInitial

#--- Get number of migration matrices -----------------
start=start+numSamples+1
numMigMat=as.numeric(unlist(strsplit(parFile[start+1], split=separator))[1])

#--- Read migration matrix
readMigMat=function(start, parFile, numSamples) {
  for (i in 1:numSamples) {
    curmigs=as.numeric(unlist(strsplit(parFile[start+i], split=separator)))
    if (i==1) {
      migs=curmigs 
    } else {
      migs=rbind(migs, curmigs)
    }
  }
  rownames(migs)=1:numSamples
  migs 
}

#--- Get migration matrices as a list --------------
start=start+2
migMats=list()
if (numMigMat>0) {
  for (i in 1:numMigMat) {  
    curMigMat=readMigMat(start, parFile, numSamples) 
    migMats[[i]]=curMigMat
    start=start+numSamples+1
  }
}

#Rescaling migration rates
if (numMigMat>0) {
  for (i in 1:numMigMat) {
    migMats[[i]]=migMats[[i]]/rescalingFactor
  }
}

#--- Get number of historical events
start=start+1
numHistEvents=as.numeric(unlist(strsplit(parFile[start], split=separator))[1])

###################### HISTORICAL EVENTS HANDLING ##############################

#..... Read Historical Event .......
last.he.time=0
if (numHistEvents>0) {
  for (i in 1:numHistEvents) {
    start=start+1
    #Take care of nomig keyword
    nomig=F
    if (grepl("nomig", parFile[start])) {
      nomig=T
      gsub("nomig", "", parFile[start])
    }
    curHE=as.numeric(unlist(strsplit(parFile[start], split=separator)))
    if (nomig) curHE[7]=-1 
    #Rescaling time of event
    curHE[1]=round(curHE[1]*rescalingFactor, digits=0)
    if (i==1) {
      histEvents=curHE
      last.he.time=curHE[1]
    } else {
      histEvents=rbind(histEvents, curHE)
      if (histEvents[i,1] > last.he.time) last.he.time=histEvents[i,1] 
    }
  }
  if (numHistEvents>1) rownames(histEvents)=1:numHistEvents
}
names(last.he.time)=""
last.he.time=as.numeric(last.he.time)

yTimeLimit=0
if (last.he.time!=0) yTimeLimit=last.he.time*(1+propLastsegment) #Add propLastsegment to y axis after last event (to draw stuff)

#Reorder events by their times
if (numHistEvents>1) histEvents=histEvents[order(histEvents[,1],decreasing=FALSE),] else {
  if (numHistEvents==1) histEvents=matrix(histEvents, nrow=1,  byrow = T)
}

endReadParFile=start



##############################  PLOTTING THE MODELED SCENARIO ######################################


#--- Graphical functions ...........................................................................

fullHeadArrow=function(x0, y0, x1, y1, length, angle, color="black",  weight=1) {
  arrows(x0, y0, x1, y1, length, angle, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.80, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.60, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.40, code=2, lty=1, col=color, lwd=weight) 
  arrows(x0, y0, x1, y1, length, angle*0.20, code=2, lty=1, col=color, lwd=weight)
  arrows(x0, y0, x1, y1, length, angle*0.10, code=2, lty=1, col=color, lwd=weight)
}
drawTriangle=function(growth, x, y, size, aspRatio, color) {
  if (growth>0) {
    x0=x; y0=y
    x1=x-size/2; y1=y+size/2*aspRatio
    x2=x+size/2; y2=y+size/2*aspRatio
  } else {
    x0=x-size/2; y0=y
    x1=x; y1=y+size/2*aspRatio
    x2=x+size/2; y2=y
  }
  polygon(c(x0, x1, x2, x0), c(y0, y1, y2, y0), col=color)
  return(y+size/2*aspRatio)
}


#--- Computing maximum current pop size ............................................................
maxPopSize=popSizes[1]
minPopSize=popSizes[1]
if (length(popSizes)>1){
  for (i in 2:length(popSizes)) {
    if (popSizes[i]>maxPopSize) maxPopSize=popSizes[i];
    if (popSizes[i]<minPopSize) minPopSize=popSizes[i];
  }
}

#--- Find min and max pop sizes over the whole population history ..................................
ps=popSizes
isGrowth=FALSE
if (numHistEvents) {
  #Need to keep track ofgrowth rates over time
  gRates=growthRates
  prevTime=0
  for (i in 1:numHistEvents) {
    he=histEvents[i,]
    curTime=he[1]
    sink=he[3]+1 
    resize=he[5]
    growth=he[6]
    
    #Begin by resizing pop sizes due to growth since last event
    for (j in 1:length(ps)) {
      ps[j]=ps[j]*exp(gRates[j]*(curTime-prevTime))
      if (ps[j]>maxPopSize) maxPopSize=ps[j]
      if (ps[j]<minPopSize) minPopSize=ps[j]
      if (ps[j]==0) print(paste("Deme ", j-1, " reaches size zero at time ",  curTime, " due to large negative growth (", gRates[j], ")", sep=""))
      if (is.infinite(ps[j])) print(paste("Deme ", j-1, " reaches infinite size at time ",  curTime, " due to large positive growth (", gRates[j], ")", sep=""))
    }
    prevTime=curTime
    
    #Handle transformed keep keyword
    if(growth!=-9999) {
      gRates[sink]=growth 
    }
    
    #Implement resize
    ps[sink]=ps[sink]*resize
    if (ps[sink]>maxPopSize) maxPopSize=ps[sink]
    if (ps[sink]<minPopSize) minPopSize=ps[sink]
  }
}

#-- Function to compute the circle radius for a given pop size ....................................
interpolRadius=function(curSize, minSize, maxSize, minRadius, maxRadius, logScale) {
  if(logScale) {
    minSize=log10(minSize)
    maxSize=log10(maxSize)
    curSize=log10(curSize)
  }
  curRadius=minRadius+(curSize-minSize)*(maxRadius-minRadius)/(maxSize-minSize)
  curRadius
}

#==============================                     ========================
#==============================   BEGIN MAIN PLOT   ========================
#==============================                     ========================

library("plotrix")
library("diagram")

if (printPDF) {
  pdf(pdfFileName, width=pdf.x.size, height=pdf.y.size)
} 

par(xpd=F, mar=c(6,4,3,0.5))

maxRadius=maxRadius*(numSamples+2)
minRadius=minRadius*(numSamples+2)

title=parFileName

plot(x=1:numSamples, type="n", xlab="", ylab="time (gen)", xlim=c(-0.5, numSamples+1.5), cex.main=0.8,
     ylim=c(0, yTimeLimit), main=title, xaxt = 'n', log=logScaleAxis, cex.axis=0.9, cex.lab=0.9)
axis(side=1, labels=c("Mig Mat",0:(numSamples-1), " \nTimes"), at=0:(numSamples+1), cex.axis=0.8)
mtext("demes", side=1,line=2, cex=0.8)

w <- par("pin")[1]/diff(par("usr")[1:2])
h <- par("pin")[2]/diff(par("usr")[3:4])
aspRatio <- w/h

# aspRatio=yTimeLimit/(numSamples+2)

#--- Plotting population circles according to their current size and sampling time
for (i in 1:numSamples) {
  curRadius=interpolRadius(popSizes[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
  #   print(curRadius)
  if (i==1) topOfCircle=sampTimes[i]+curRadius*aspRatio else topOfCircle=c(topOfCircle, sampTimes[i]+curRadius*aspRatio)
  curColor=popCol
  if (sampSizes[i]==0) curColor="white"
  if (inbrCoeff[i]==0) {
    draw.circle(i, sampTimes[i], radius = curRadius, col=curColor, border=popBorderCol) 
  } else {
    floating.pie(i, sampTimes[i], c(inbrCoeff[i], 1-inbrCoeff[i]), radius = curRadius, 
                 col=c(inbreedColor,curColor), startpos=pi, border=popBorderCol)    
  }
  if (sampTimes[i]>0) {
    text(i, sampTimes[i]-curRadius*aspRatio, labels=sampTimes[i], cex=timeProp, col=oldSampColor, pos=1)
  }
  #Draw a vertical arrow in case of pop growth
  curGrowthRate=growthRates[i]
  
  #--- Draw gtrowing or shrinking triangle on top of pop circle to reflect growth type
  if (curGrowthRate!=0) {
    arLength=0.15
    topOfCircle[i]=drawTriangle(curGrowthRate, x=i, y=topOfCircle[i], arLength, aspRatio, color=growthCol)
  }
}

#--- Handle first migration matrix .......................
curMigMatNum=0
curvature=0.0075*last.he.time
text(0-migrOffset, 0, labels=0, cex=migMatNameProp, col=migrMatCol)
if (numMigMat) {
  curMigMat=migMats[1][[1]]
  for (sink in 1:numSamples) {
    for (sourc in 1:numSamples) {
      if (sink!=sourc & curMigMat[sourc, sink]>0)  {
        differ=sourc-sink
        curvedarrow(from=c(sourc, 0), to=c(sink,0), curve=curvature*(abs(differ)*0.55^abs(differ)), arr.adj=1, 
                    arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY, 
                    lcol=migrMatCol, arr.length=arrowLength)   
        if (plotMigrRates) {
          curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)        
          if (differ>0) {
            text(sink+abs(differ)/2, aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
          } else {
            text(sourc+abs(differ)/2, -aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
          } 
        }
      }
    }
  }
}

#---Draw all events on the population tree
lastTime=0
activePops=1:numSamples
numActivePops=numSamples
lastSink=-1
if (numHistEvents) {
  for (i in 1:numHistEvents) {
    #Extract historical event
    he=histEvents[i,]
    he.time=he[1]
    he.source=he[2]+1 #+1 is due to the use of base 0 for deme number in fsc
    he.sink=he[3]+1
    he.migr=he[4]
    he.resize=he[5]
    he.growth=he[6]
    if(he.growth==-9999) { #handle transformed keep keyword
      he.growth=growthRates[he.sink] #Keep current growth rate
    }
    he.migrMat=he[7]
    
    if(he.migrMat==-9999) { #handle transformed keep keyword
      he.migrMat=curMigMatNum
    }
    
    #-- Draw event time
    if (i%%2) {
      slide=timeOffset
    }
    else {
      slide=-timeOffset
    }
    
    #Draw all vertical segments ....................
    for (p in 1:length(activePops)) {
      #Handle population with older sampling times
      if (sampTimes[activePops[p]]>0) {
        minTime=max(lastTime, topOfCircle[activePops[p]]);
      } else {
        minTime=lastTime;
      }
      if (he.time>sampTimes[activePops[p]] & he.time>topOfCircle[activePops[p]]) {
        if (activePops[p]==lastSink | i==1) {
          segments(activePops[p], topOfCircle[activePops[p]], activePops[p], he.time)    
        } else {
          segments(activePops[p], minTime, activePops[p], he.time)        
        }
      }
    }     
    
    #Handle growth rate changes since last event ......................
    #Update pop sizes according to current growth rates
    if (i>1) {
      prev.he=histEvents[i-1,] 
      branchLength=he.time-lastTime
      for (p in 1:length(activePops)) {
        curPop=activePops[p]
        popSizes[curPop]=popSizes[curPop]*exp(growthRates[curPop]*branchLength);
      }
    }
    #Update growth rate
    growthRates[he.sink]=he.growth
    
    
    lastTime=he.time
    #Handle resize of sink pop ........................
    popSizes[he.sink]=popSizes[he.sink]*he.resize
    
    curRadius=interpolRadius(popSizes[he.sink], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
    #     popRadius[he.sink]=curRadius
    topOfCircle[he.sink]=he.time+curRadius*aspRatio
    draw.circle(he.sink, he.time, radius = curRadius, col=popCol, border=popBorderCol)
    
    
    #--- Draw growing or shrinking triangle on top of pop circle to reflect growth type
    if (he.growth!=0) {
      arLength=0.15
      topOfCircle[he.sink]=drawTriangle(he.growth, x=he.sink, y=topOfCircle[he.sink], arLength, aspRatio, color=growthCol)
    }
    
    #Handle population fusion .........................
    if (he.migr>=1 & he.sink!=he.source) { #This is a population fusion
      if (numActivePops==numSamples) removedPops=he.source else removedPops=c(removedPops, he.source)
      numActivePops=numActivePops-1
      activePops=(1:numSamples)[-removedPops]
      #Draw connecting arrows from source to sink
      fullHeadArrow(he.source, he.time, he.sink, he.time, length=0.15, angle=20)      
      #Redraw time with the right color
      text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=popFusionColor)
    } else {
      #--- Handle admixture event ........................
      if (he.migr>0 & he.migr<1) { 
        #Draw connecting arrows from source to sink      
        segments(he.source, he.time, he.sink, he.time, col=admixCol, lty=2)
        if (he.sink>he.source) {
          fullHeadArrow(he.sink-0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
        } else {
          fullHeadArrow(he.sink+0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
        }     
        #Redraw time with the right color
        text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=admixCol)
      }
      else text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=timeCol)
    }    
    
    
    #--- Handle migmat change  ............................
    if (i!=numHistEvents) nextTime=histEvents[i+1,1] else {
      nextTime=yTimeLimit
    }
    time2DrawArrows=(he.time+nextTime)/2
    
    if (he.migrMat!=curMigMatNum) {
      if (he.migrMat>-1) {
        curMigMat=migMats[he.migrMat+1][[1]]
        for (sink in 1:numSamples) {
          for (sourc in 1:numSamples) {
            if (sink!=sourc & curMigMat[sourc, sink]>0)  {  
              differ=sourc-sink
              curvedarrow(from=c(sourc, time2DrawArrows), to=c(sink, time2DrawArrows), curve=curvature*(abs(differ)*0.55^abs(differ)), 
                          arr.adj=1, arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY, 
                          lcol=migrMatCol, arr.length=arrowLength)  
              if (plotMigrRates) {
                #Write Nm values
                curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)
                if (differ>0) {
                  text(sink+abs(differ)/2, time2DrawArrows+aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
                } else {
                  text(sourc+abs(differ)/2, time2DrawArrows-aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol) 
                } 
              }
            }
          }
          # curMigMatNum=he.migrMat
        }
      } 
      #--- Draw separation between migration matrices numbers on the left
      segments(-migMatLineLength/2, he.time, migMatLineLength/2, he.time, lty=3, col=migrMatCol)
    } 
    curMigMatNum=he.migrMat
    
    #Output current valid migration matrix      
    if (i%%2) {
      slide=migrOffset
    }
    else {
      slide=-migrOffset
    }   
    if (he.migrMat>-1) {
      migText=he.migrMat
      curCex=migMatNameProp
    } else {
      migText="nomig"
      curCex=migMatNameProp/2
      slide=slide*2
    }
    text(0+slide, time2DrawArrows, labels=migText, cex=curCex, col=migrMatCol)    
    
    lastSink=he.sink
  }
}

#-- Draw last branch
segments(activePops[1],topOfCircle[activePops[1]], activePops[1], yTimeLimit)

#==============================   PLOT LEGENDS IN MARGINS   ========================

#Compute space available in margin
minY.coo=grconvertY(0, from="nic", to="user")

par(xpd=NA)
#--- Draw population size scale with circles of different sizes .................
maxOrder=ceiling(log10(maxPopSize))
minOrder=floor(log10(minPopSize))
popSizeRadius=10^(maxOrder:minOrder)
winWidth=numSamples+2
ypos=3/4*minY.coo
text(x=-winWidth/10*1.2, y=ypos, labels="Pop. \nsizes ", cex=.8, pos=2)

for (i in 1:length(popSizeRadius)) {
  curRadius=interpolRadius(popSizeRadius[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
  #   print(curRadius)
  if (curRadius>0) {
    xpos=-winWidth/10+(i-1)*winWidth/10
    draw.circle(xpos, ypos, radius=curRadius, col=popCol, border=popBorderCol)
  }
  text(xpos, ypos-abs(ypos)*0.1, popSizeRadius[i], cex=0.7, pos=1, col="black")
}

#--- Legend for growing or shrinking populations ...............................
if (isGrowth) {
  x=winWidth-1.5*winWidth/10; y=ypos+abs(ypos)*0.2
  text(x, y-abs(ypos)*0.1, labels="Populations", cex=0.8)
  x=winWidth-2*winWidth/10; y=ypos-abs(ypos)*0.1
  drawTriangle(1, x, y, size=0.15, aspRatio, color=growthCol)
  text(x, y-abs(ypos)*0.1, labels="growing", pos=NULL, cex=0.7)
  x=winWidth-winWidth/10
  drawTriangle(-1, x, y, size=0.15, aspRatio, color=growthCol)
  text(x, y-abs(ypos)*0.1, labels="shrinking", pos=NULL, cex=0.7)  
}


#if (printPDF) dev.off()
dev.off()
```